import XCTest
@testable import SafetyRingApp
import Foundation

final class SafetyRingAppLocalizationTests: XCTestCase {
    
    var emergencyManager: EmergencyMessageManager!
    var multiPlatformManager: MultiPlatformMessageManager!
    
    override func setUpWithError() throws {
        try super.setUpWithError()
        emergencyManager = EmergencyMessageManager()
        multiPlatformManager = MultiPlatformMessageManager()
    }
    
    override func tearDownWithError() throws {
        emergencyManager = nil
        multiPlatformManager = nil
        try super.tearDownWithError()
    }
    
    // MARK: - French Localization Tests
    
    func testFrenchLocalization() throws {
        // Test que l'application supporte le fran√ßais
        let locale = Locale(identifier: "fr_FR")
        XCTAssertEqual(locale.languageCode, "fr", "La langue fran√ßaise doit √™tre support√©e")
        XCTAssertEqual(locale.regionCode, "FR", "La r√©gion fran√ßaise doit √™tre support√©e")
        
        // Test des templates en fran√ßais
        let frenchTemplates = emergencyManager.templates.filter { template in
            template.name.contains("üö®") || template.name.contains("üè•") || template.name.contains("üöó")
        }
        
        XCTAssertFalse(frenchTemplates.isEmpty, "Il doit y avoir des templates en fran√ßais")
        
        // V√©rifier que les messages d'urgence sont en fran√ßais
        for template in frenchTemplates {
            XCTAssertTrue(template.message.contains("ALERTE"), "Le message doit contenir 'ALERTE' en fran√ßais")
            XCTAssertTrue(template.message.contains("urgence"), "Le message doit contenir 'urgence' en fran√ßais")
        }
    }
    
    func testFrenchEmergencyMessages() throws {
        // Test des messages d'urgence en fran√ßais
        let template = emergencyManager.templates.first!
        let mockLocation = createMockLocation()
        
        let message = emergencyManager.generateEmergencyMessage(template: template, location: mockLocation)
        
        // V√©rifier les √©l√©ments fran√ßais dans le message
        XCTAssertTrue(message.contains("ALERTE"), "Le message doit contenir 'ALERTE'")
        XCTAssertTrue(message.contains("urgence"), "Le message doit contenir 'urgence'")
        XCTAssertTrue(message.contains("aide"), "Le message doit contenir 'aide'")
        XCTAssertTrue(message.contains("imm√©diatement"), "Le message doit contenir 'imm√©diatement'")
    }
    
    func testFrenchLocationText() throws {
        // Test du texte de localisation en fran√ßais
        let mockLocation = createMockLocation()
        
        let emergencyText = mockLocation.getEmergencyLocationText()
        
        // V√©rifier les √©l√©ments fran√ßais dans le texte de localisation
        XCTAssertTrue(emergencyText.contains("Adresse"), "Le texte doit contenir 'Adresse' en fran√ßais")
        XCTAssertTrue(emergencyText.contains("GPS"), "Le texte doit contenir 'GPS'")
        XCTAssertTrue(emergencyText.contains("Carte"), "Le texte doit contenir 'Carte' en fran√ßais")
        XCTAssertTrue(emergencyText.contains("Heure"), "Le texte doit contenir 'Heure' en fran√ßais")
    }
    
    // MARK: - English Localization Tests
    
    func testEnglishLocalization() throws {
        // Test que l'application peut supporter l'anglais
        let locale = Locale(identifier: "en_US")
        XCTAssertEqual(locale.languageCode, "en", "La langue anglaise doit √™tre support√©e")
        XCTAssertEqual(locale.regionCode, "US", "La r√©gion am√©ricaine doit √™tre support√©e")
        
        // Note: L'application est actuellement en fran√ßais uniquement
        // Ces tests v√©rifient la capacit√© future de support multilingue
        XCTAssertTrue(true, "L'application doit pouvoir supporter l'anglais √† l'avenir")
    }
    
    // MARK: - Date and Time Formatting Tests
    
    func testFrenchDateFormatting() throws {
        // Test du formatage des dates en fran√ßais
        let date = Date()
        let formatter = DateFormatter()
        
        // Format fran√ßais
        formatter.locale = Locale(identifier: "fr_FR")
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        
        let frenchDateString = formatter.string(from: date)
        
        // V√©rifier que la date est format√©e en fran√ßais
        XCTAssertFalse(frenchDateString.isEmpty, "La date fran√ßaise ne doit pas √™tre vide")
        
        // V√©rifier les √©l√©ments fran√ßais typiques
        let containsFrenchElements = frenchDateString.contains("janv") || 
                                   frenchDateString.contains("f√©vr") || 
                                   frenchDateString.contains("mars") ||
                                   frenchDateString.contains("avr") ||
                                   frenchDateString.contains("mai") ||
                                   frenchDateString.contains("juin") ||
                                   frenchDateString.contains("juil") ||
                                   frenchDateString.contains("ao√ªt") ||
                                   frenchDateString.contains("sept") ||
                                   frenchDateString.contains("oct") ||
                                   frenchDateString.contains("nov") ||
                                   frenchDateString.contains("d√©c")
        
        XCTAssertTrue(containsFrenchElements, "La date doit contenir des mois en fran√ßais")
    }
    
    func testFrenchTimeFormatting() throws {
        // Test du formatage de l'heure en fran√ßais
        let date = Date()
        let formatter = DateFormatter()
        
        // Format fran√ßais
        formatter.locale = Locale(identifier: "fr_FR")
        formatter.timeStyle = .short
        
        let frenchTimeString = formatter.string(from: date)
        
        // V√©rifier que l'heure est format√©e en fran√ßais
        XCTAssertFalse(frenchTimeString.isEmpty, "L'heure fran√ßaise ne doit pas √™tre vide")
        
        // V√©rifier le format 24h typique en fran√ßais
        XCTAssertTrue(frenchTimeString.contains(":"), "L'heure doit contenir ':'")
    }
    
    // MARK: - Number Formatting Tests
    
    func testFrenchNumberFormatting() throws {
        // Test du formatage des nombres en fran√ßais
        let number = 1234.56
        let formatter = NumberFormatter()
        
        // Format fran√ßais
        formatter.locale = Locale(identifier: "fr_FR")
        formatter.numberStyle = .decimal
        formatter.minimumFractionDigits = 2
        formatter.maximumFractionDigits = 2
        
        let frenchNumberString = formatter.string(from: NSNumber(value: number))
        
        // V√©rifier que le nombre est format√© en fran√ßais
        XCTAssertFalse(frenchNumberString.isEmpty, "Le nombre fran√ßais ne doit pas √™tre vide")
        
        // V√©rifier l'utilisation de la virgule comme s√©parateur d√©cimal
        XCTAssertTrue(frenchNumberString?.contains(",") == true, "Le nombre doit utiliser la virgule comme s√©parateur d√©cimal")
        
        // V√©rifier l'utilisation de l'espace comme s√©parateur de milliers
        XCTAssertTrue(frenchNumberString?.contains(" ") == true, "Le nombre doit utiliser l'espace comme s√©parateur de milliers")
    }
    
    // MARK: - Currency Formatting Tests
    
    func testFrenchCurrencyFormatting() throws {
        // Test du formatage de la monnaie en fran√ßais
        let amount = 1234.56
        let formatter = NumberFormatter()
        
        // Format fran√ßais avec euro
        formatter.locale = Locale(identifier: "fr_FR")
        formatter.numberStyle = .currency
        formatter.currencyCode = "EUR"
        
        let frenchCurrencyString = formatter.string(from: NSNumber(value: amount))
        
        // V√©rifier que la monnaie est format√©e en fran√ßais
        XCTAssertFalse(frenchCurrencyString.isEmpty, "La monnaie fran√ßaise ne doit pas √™tre vide")
        
        // V√©rifier l'utilisation du symbole euro
        XCTAssertTrue(frenchCurrencyString?.contains("‚Ç¨") == true, "La monnaie doit contenir le symbole euro")
        
        // V√©rifier l'utilisation de la virgule comme s√©parateur d√©cimal
        XCTAssertTrue(frenchCurrencyString?.contains(",") == true, "La monnaie doit utiliser la virgule comme s√©parateur d√©cimal")
    }
    
    // MARK: - Address Formatting Tests
    
    func testFrenchAddressFormatting() throws {
        // Test du formatage des adresses en fran√ßais
        let mockLocation = createMockLocation()
        
        let formattedLocation = mockLocation.getFormattedLocation()
        
        // V√©rifier que l'adresse est format√©e correctement
        XCTAssertFalse(formattedLocation.isEmpty, "L'adresse format√©e ne doit pas √™tre vide")
        XCTAssertTrue(formattedLocation.contains("Paris"), "L'adresse doit contenir la ville")
        XCTAssertTrue(formattedLocation.contains("France"), "L'adresse doit contenir le pays")
        
        // V√©rifier le format fran√ßais typique (code postal avant ville)
        XCTAssertTrue(formattedLocation.contains("75001"), "L'adresse doit contenir le code postal")
    }
    
    // MARK: - Emergency Numbers Tests
    
    func testFrenchEmergencyNumbers() throws {
        // Test des num√©ros d'urgence fran√ßais
        let emergencyNumbers = ["17", "15", "18"]
        
        for number in emergencyNumbers {
            let recipient = MessageRecipient(
                phoneNumber: number,
                name: "Emergency \(number)",
                platforms: [.sms]
            )
            
            XCTAssertEqual(recipient.phoneNumber, number, "Le num√©ro d'urgence doit √™tre correct")
            XCTAssertTrue(recipient.platforms.contains(.sms), "Les num√©ros d'urgence doivent supporter SMS")
        }
    }
    
    // MARK: - Platform Names Tests
    
    func testFrenchPlatformNames() throws {
        // Test des noms de plateformes en fran√ßais
        let platforms: [MessagePlatform] = [.sms, .whatsapp, .telegram, .signal]
        
        for platform in platforms {
            // V√©rifier que la plateforme a un nom et une ic√¥ne
            XCTAssertFalse(platform.rawValue.isEmpty, "La plateforme doit avoir un nom")
            XCTAssertFalse(platform.icon.isEmpty, "La plateforme doit avoir une ic√¥ne")
            XCTAssertFalse(platform.color.isEmpty, "La plateforme doit avoir une couleur")
        }
    }
    
    // MARK: - Template Categories Tests
    
    func testFrenchTemplateCategories() throws {
        // Test des cat√©gories de templates en fran√ßais
        let categories: [EmergencyCategory] = [.aggression, .medical, .accident, .danger, .custom]
        
        for category in categories {
            // V√©rifier que la cat√©gorie a un nom et une ic√¥ne
            XCTAssertFalse(category.name.isEmpty, "La cat√©gorie doit avoir un nom")
            XCTAssertFalse(category.icon.isEmpty, "La cat√©gorie doit avoir une ic√¥ne")
            XCTAssertNotNil(category.color, "La cat√©gorie doit avoir une couleur")
        }
    }
    
    // MARK: - Accessibility Tests
    
    func testFrenchAccessibility() throws {
        // Test de l'accessibilit√© en fran√ßais
        let emergencyButton = "üö® ALERTE D'URGENCE"
        let settingsButton = "Param√®tres"
        let addButton = "Ajouter"
        
        // V√©rifier que les boutons ont des noms en fran√ßais
        XCTAssertTrue(emergencyButton.contains("ALERTE"), "Le bouton d'urgence doit √™tre en fran√ßais")
        XCTAssertTrue(emergencyButton.contains("URGENCE"), "Le bouton d'urgence doit √™tre en fran√ßais")
        XCTAssertTrue(settingsButton.contains("Param√®tres"), "Le bouton des param√®tres doit √™tre en fran√ßais")
        XCTAssertTrue(addButton.contains("Ajouter"), "Le bouton d'ajout doit √™tre en fran√ßais")
    }
    
    // MARK: - Error Messages Tests
    
    func testFrenchErrorMessages() throws {
        // Test des messages d'erreur en fran√ßais
        let errorMessages = [
            "Erreur",
            "Avertissement",
            "Information",
            "Succ√®s"
        ]
        
        for message in errorMessages {
            XCTAssertFalse(message.isEmpty, "Le message d'erreur ne doit pas √™tre vide")
            XCTAssertTrue(message.count > 0, "Le message d'erreur doit avoir du contenu")
        }
    }
    
    // MARK: - Success Messages Tests
    
    func testFrenchSuccessMessages() throws {
        // Test des messages de succ√®s en fran√ßais
        let successMessages = [
            "Envoy√©",
            "Termin√©",
            "Succ√®s",
            "OK"
        ]
        
        for message in successMessages {
            XCTAssertFalse(message.isEmpty, "Le message de succ√®s ne doit pas √™tre vide")
            XCTAssertTrue(message.count > 0, "Le message de succ√®s doit avoir du contenu")
        }
    }
    
    // MARK: - Navigation Tests
    
    func testFrenchNavigation() throws {
        // Test de la navigation en fran√ßais
        let navigationItems = [
            "Accueil",
            "Param√®tres",
            "Destinataires",
            "Templates",
            "Historique",
            "Aide"
        ]
        
        for item in navigationItems {
            XCTAssertFalse(item.isEmpty, "L'√©l√©ment de navigation ne doit pas √™tre vide")
            XCTAssertTrue(item.count > 0, "L'√©l√©ment de navigation doit avoir du contenu")
        }
    }
    
    // MARK: - Status Messages Tests
    
    func testFrenchStatusMessages() throws {
        // Test des messages de statut en fran√ßais
        let statusMessages = [
            "Connect√©",
            "D√©connect√©",
            "En ligne",
            "Hors ligne",
            "Active",
            "Inactive"
        ]
        
        for message in statusMessages {
            XCTAssertFalse(message.isEmpty, "Le message de statut ne doit pas √™tre vide")
            XCTAssertTrue(message.count > 0, "Le message de statut doit avoir du contenu")
        }
    }
    
    // MARK: - Action Messages Tests
    
    func testFrenchActionMessages() throws {
        // Test des messages d'action en fran√ßais
        let actionMessages = [
            "D√©clencher",
            "Arr√™ter",
            "Confirmer",
            "Annuler",
            "Enregistrer",
            "Supprimer",
            "Modifier",
            "Ajouter",
            "Fermer",
            "Retour"
        ]
        
        for message in actionMessages {
            XCTAssertFalse(message.isEmpty, "Le message d'action ne doit pas √™tre vide")
            XCTAssertTrue(message.count > 0, "Le message d'action doit avoir du contenu")
        }
    }
    
    // MARK: - Test Helpers
    
    private func createMockLocation() -> LocationManager {
        let location = LocationManager()
        location.lastCoordinate = CLLocationCoordinate2D(latitude: 48.8566, longitude: 2.3522)
        location.lastAddress = "1 Rue de la Paix, 75001 Paris, France"
        location.isLocationEnabled = true
        return location
    }
    
    private func createMockEmergencyTemplate() -> EmergencyTemplate {
        return EmergencyTemplate(
            id: "localization-test",
            name: "Test de Localisation",
            message: "üö® TEST - {ADDRESS} - {GPS} - {TIME}",
            isActive: true,
            category: .custom
        )
    }
    
    private func createMockRecipient() -> MessageRecipient {
        return MessageRecipient(
            phoneNumber: "+33123456789",
            name: "Test de Localisation",
            platforms: [.sms, .whatsapp]
        )
    }
}
